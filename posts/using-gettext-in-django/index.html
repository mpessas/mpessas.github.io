<!DOCTYPE html>
































<html
  class="not-ready lg:text-base"
  style="--bg: #fbfbfb"
  lang="en-us"
>
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, shrink-to-fit=no"
  />

  
  <title>Using gettext in Django - That&#39;s weird...</title>

  
  <meta name="theme-color" />

  
  
  
  <meta name="description" content="Internationalization (i18n) is the process of enabling your software to be translated to other languages. This is done by making the software able to map all user-visible strings to their translations in a specific language and use them, when appropriate.
The i18n toolset django uses is gettext and is enabled with the USE_I18N setting. Gettext works as follows: First, the developer marks the translation strings in the source code and then he runs the xgettext command to create the source PO file." />
  <meta name="author" content="Apostolis Bessas" />
  

  
  
  
  
  
  
  <link rel="preload stylesheet" as="style" href="https://blog.bessas.me/main.min.css" />

  
  <script
    defer
    src="https://blog.bessas.me/highlight.min.js"
    onload="hljs.initHighlightingOnLoad();"
  ></script>
  

  
   
  <link rel="preload" as="image" href="https://blog.bessas.me/theme.png" />

  
  
  
  

  
  <link rel="preload" as="image" href="https://blog.bessas.me/github.svg" />
  
  <link rel="preload" as="image" href="https://blog.bessas.me/rss.svg" />
  
  

  
  

  
  <link rel="icon" href="https://blog.bessas.me/favicon.ico" />
  <link rel="apple-touch-icon" href="https://blog.bessas.me/apple-touch-icon.png" />

  
  <meta name="generator" content="Hugo 0.101.0" />

  
  

  
  
  
  
  
  
  
  <meta property="og:title" content="Using gettext in Django" />
<meta property="og:description" content="Internationalization (i18n) is the process of enabling your software to be translated to other languages. This is done by making the software able to map all user-visible strings to their translations in a specific language and use them, when appropriate.
The i18n toolset django uses is gettext and is enabled with the USE_I18N setting. Gettext works as follows: First, the developer marks the translation strings in the source code and then he runs the xgettext command to create the source PO file." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.bessas.me/posts/using-gettext-in-django/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2013-11-02T11:20:24+02:00" />
<meta property="article:modified_time" content="2013-11-02T11:20:24+02:00" />


  
  <meta itemprop="name" content="Using gettext in Django">
<meta itemprop="description" content="Internationalization (i18n) is the process of enabling your software to be translated to other languages. This is done by making the software able to map all user-visible strings to their translations in a specific language and use them, when appropriate.
The i18n toolset django uses is gettext and is enabled with the USE_I18N setting. Gettext works as follows: First, the developer marks the translation strings in the source code and then he runs the xgettext command to create the source PO file."><meta itemprop="datePublished" content="2013-11-02T11:20:24+02:00" />
<meta itemprop="dateModified" content="2013-11-02T11:20:24+02:00" />
<meta itemprop="wordCount" content="943">
<meta itemprop="keywords" content="" />
  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Using gettext in Django"/>
<meta name="twitter:description" content="Internationalization (i18n) is the process of enabling your software to be translated to other languages. This is done by making the software able to map all user-visible strings to their translations in a specific language and use them, when appropriate.
The i18n toolset django uses is gettext and is enabled with the USE_I18N setting. Gettext works as follows: First, the developer marks the translation strings in the source code and then he runs the xgettext command to create the source PO file."/>

  
  
</head>

  <body class="text-black duration-200 ease-out dark:text-white">
    <header class="mx-auto flex h-[4.5rem] max-w-3xl px-8 lg:justify-center">
  <div class="relative z-50 mr-auto flex items-center">
    <a
      class="-translate-x-[1px] -translate-y-[1px] text-2xl font-semibold"
      href="https://blog.bessas.me/"
      >That&#39;s weird...</a
    >
    <div
      class="btn-dark text-[0] ml-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]"
      role="button"
      aria-label="Dark"
    ></div>
  </div>

  <div
    class="btn-menu relative z-50 -mr-8 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden"
    role="button"
    aria-label="Menu"
  ></div>

  
  <script>
    
    const htmlClass = document.documentElement.classList;
    setTimeout(() => {
      htmlClass.remove('not-ready');
    }, 10);

    
    const btnMenu = document.querySelector('.btn-menu');
    btnMenu.addEventListener('click', () => {
      htmlClass.toggle('open');
    });

    
    const metaTheme = document.querySelector('meta[name="theme-color"]');
    const lightBg = '#fbfbfb'.replace(/"/g, '');
    const setDark = (isDark) => {
      metaTheme.setAttribute('content', isDark ? '#000' : lightBg);
      htmlClass[isDark ? 'add' : 'remove']('dark');
      localStorage.setItem('dark', isDark);
    };

    
    const darkScheme = window.matchMedia('(prefers-color-scheme: dark)');
    if (htmlClass.contains('dark')) {
      setDark(true);
    } else {
      const darkVal = localStorage.getItem('dark');
      setDark(darkVal ? darkVal === 'true' : darkScheme.matches);
    }

    
    darkScheme.addEventListener('change', (event) => {
      setDark(event.matches);
    });

    
    const btnDark = document.querySelector('.btn-dark');
    btnDark.addEventListener('click', () => {
      setDark(localStorage.getItem('dark') !== 'true');
    });
  </script>

  <div
    class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"
  >
    
    

    
    <nav
      class="mt-12 flex justify-center space-x-10 dark:invert lg:ml-12 lg:mt-0 lg:items-center lg:space-x-6"
    >
      
      <a
        class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./github.svg)"
        href="https://github.com/mpessas"
        target="_blank"
        rel="me"
      >
        github
      </a>
      
      <a
        class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./rss.svg)"
        href="https://blog.bessas.me/index.xml"
        target="_blank"
        rel="alternate"
      >
        rss
      </a>
      
    </nav>
    
  </div>
</header>


    <main
      class="prose prose-neutral relative mx-auto min-h-[calc(100%-9rem)] max-w-3xl px-8 pb-16 pt-12 dark:prose-invert"
    >
      

<article>
  <header class="mb-16">
    <h1 class="!my-0 pb-2.5">Using gettext in Django</h1>

    
    <div class="text-sm antialiased opacity-60">
      
      <time>Nov 2, 2013</time>
      
      
      
      
      <span class="mx-1">&middot;</span>
      <span>Apostolis Bessas</span>
      
    </div>
    
  </header>

  <section><p>Internationalization (i18n) is the process of enabling your software to be
translated to other languages. This is done by making the software able to map
all user-visible strings to their translations in a specific language and use
them, when appropriate.</p>
<p>The i18n toolset django uses is <strong>gettext</strong> and is enabled with the <code>USE_I18N</code>
setting. Gettext works as follows: First, the developer marks the <strong>translation
strings</strong> in the source code and then he runs the <code>xgettext</code> command to create
the source PO file. The <code>xgettext</code> command analyzes the source code to locate
the strings that were marked as translation strings and
extracts them into a PO file, which can be translated to the target languages.
The last step is to <em>compile</em> the PO files into binary message files (.mo files) with
the <code>msgfmt</code> command.</p>
<p>Django makes sure to ease the process by providing its own management commands:
<code>makemessages</code> that extracts the strings from the source code and
<code>compilemessages</code> that converts the files into the binary ones. It also expects to find the PO files for a language under the directory
<code>locale/&lt;locale&gt;/LC_MESSAGES/django.po</code>, where <code>&lt;locale&gt;</code> is the language code.</p>
<p>In the runtime, whenever a gettext function is used, it will use the PO file
that corresponds to the currently active locale and return the correct
translation that corresponds to this string. If no translation is found, the
original string is used instead.</p>
<h2 id="the-gettext-functions">The gettext functions</h2>
<p>The following is a list of the most important gettext functions that django
exposes and can support unicode strings correctly. Keep in mind that they all
mark the containing <em>literal string</em> as translatable, that is, you need to pass
the string itself as an argument, not a variable.</p>
<ul>
<li><code>ugettext</code>: The function returns the   translation for the currently selected language.</li>
<li><code>ugettext_lazy</code>: The function marks the string as translation string, but only
fetches the translated string, when it is used in a string context, such as
when rendering a template.</li>
<li><code>ugettext_noop</code>: This function only marks a string as translation string, it
does not have any other effect; that is, it always returns the string itself.</li>
</ul>
<p>The <code>ugettext_lazy</code> function is useful in cases, where a string needs to be
marked as translation string, but the user&rsquo;s locale is not active yet. For
instance, all strings in a model or in the settings are loaded, when the django
process is started. During startup, there is no user request that sets the
active locale. By using the <code>ugettext_lazy</code> function, you ensure that the
translations will be actually fetched only during a user request, when the locale is known.</p>
<p>Given the <code>ugettext_lazy</code> function, the <code>ugettext_noop</code> function seems to be
redundant. However, it is really useful in cases that you want to mark a string
as translation string, but need to use it in other contexts in its original form
as well, such as an error message that has to be logged, too. For instance, take
the following view that returns an error message to the user (it is a standard practice to import the gettext functions as &ldquo;<code>_</code>&rdquo;):</p>
<pre><code>import logging
from django.http import HttpResponse
from django.utils.translation import ugettext as _

def view(request):
    msg = _(&quot;An error has occurred&quot;)
    logging.error(msg)
    return HttpResponse(msg)
</code></pre>
<p>The response will contain the translated error message, but so will the logs. In
order to circumvent this issue, you can use the <code>ugettext_noop</code> function
instead:</p>
<pre><code>import logging
from django.http import HttpResponse
from django.utils.translation import ugettext as _, ugettext_noop as _noop

def view(request):
    msg = _noop(&quot;An error has occurred&quot;)
    logging.error(msg)
    return HttpResponse(_(msg))
</code></pre>
<p>The <code>ugettext_noop</code> will force gettext to mark the error message as translation
string, but it will return the original (English) string. As a result, the log
messages will use the English phrase. However, we still want to present the
translated message to the user. We achieve this by using the <code>ugettext</code> function
to force evaluating the string and fetching the translated message. This
technique is especially useful for exception messages, that need to be logged in
a higher layer of the codebase but also presented to the user.</p>
<h2 id="plural-support">Plural support</h2>
<p>Most languages have two <strong>plural forms</strong>: singular and plural. Some languages,
however, have only one, like Japanese. Others can have up to six, like Arabic.</p>
<p>Which plural  form to use  depends on the number of objects the phrase refers to.  For instance, English  uses the
singular  form, when  the phrase  refers  to one  object (&ldquo;1  language&rdquo;), and  the
plural, when it refers to none (&ldquo;no languages&rdquo;) or more than one (&ldquo;2 languages&rdquo;). Other languages have different rules.</p>
<p>Django supports plurals with the <code>n</code> family of gettext functions: <code>ungettext</code>
and <code>ungettext_lazy</code>.</p>
<h2 id="context-support">Context support</h2>
<p>Gettext allows developers to define the <strong>context</strong> of a string. For instance,
the word &ldquo;Read&rdquo; can mean &ldquo;read an email&rdquo; or &ldquo;emails read&rdquo;. The developer can
define and explain the context of a string to differentiate between the two uses. This way, gettext will create
separate entries for the word &ldquo;read&rdquo;, one for each context.</p>
<p>This is supported in django with the <code>p</code> family of gettext functions:
<code>pgettext</code>, <code>pgettext_lazy</code>, <code>npgettext</code> and <code>npgettext_lazy</code>.</p>
<h2 id="support-in-templates">Support in templates</h2>
<p>Django provides two <em>templatetags</em> for marking translation strings in templates:
<code>trans</code> and <code>blocktrans</code>. The main difference is that the <code>trans</code> templatetag
only supports simple strings, while the <code>blocktrans</code> templatetag supports
variable substitution (placeholders) as well.</p>
<p>Both templatetags support most of the gettext features. One thing to keep in
mind for the <code>blocktrans</code> templatetag, though, is that the containing string is
extracted as is. This means that the string will be extracted by gettext with
any newline and space characters or indentation it might have. For this reason,
all indentation should be avoided.</p>
<p>More details for how to internationalize your web application can be found at
<a href="https://docs.djangoproject.com/en/dev/topics/i18n/translation/">django&rsquo;s documentation</a>.</p>
</section>

  
  

  
  
  
  <nav class="mt-24 flex rounded-lg bg-black/[3%] text-lg dark:bg-white/[8%]">
    
    <a
      class="flex w-1/2 items-center rounded-l-md p-6 pr-3 font-semibold no-underline hover:bg-black/[2%] dark:hover:bg-white/[3%]"
      href="https://blog.bessas.me/posts/exposing-objects-in-multiple-represenations/"
      ><span class="mr-1.5">←</span><span>Exposing objects in multiple represenations</span></a
    >
    
    
    <a
      class="ml-auto flex w-1/2 items-center justify-end rounded-r-md p-6 pl-3 font-semibold no-underline hover:bg-black/[2%] dark:hover:bg-white/[3%]"
      href="https://blog.bessas.me/posts/running-tests-in-memory-with-postgresql/"
      ><span>Running your Django tests in memory with PostgreSQL</span><span class="ml-1.5">→</span></a
    >
    
  </nav>
  

  
  

  
  
</article>


    </main>

    <footer
  class="opaco mx-auto flex h-[4.5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"
>
  <div class="mr-auto">
    &copy; 2023
    <a class="link" href="https://blog.bessas.me/">Apostolis Bessas</a>
  </div>
</footer>

  </body>
</html>
